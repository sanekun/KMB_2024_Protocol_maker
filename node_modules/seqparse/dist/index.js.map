{"version":3,"file":"index.js","mappings":"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QAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,EAAlC,CAAkC,CAAC;aAClD,GAAG,CAAC,WAAC,IAAI,QAAC;YACT,KAAK,EAAE,CAAC,CAAC,KAAK;YACd,SAAS,EAAE,CAAC,CAAC,SAAS;YACtB,GAAG,EAAE,CAAC,CAAC,GAAG;YACV,IAAI,EAAE,CAAC,CAAC,IAAI;YACZ,KAAK,EAAE,CAAC,CAAC,KAAK;YACd,IAAI,EAAE,CAAC,CAAC,IAAI;SACb,CAAC,EAPQ,CAOR,CAAC;QACL,IAAI,EAAE,CAAC,CAAC,IAAI;QACZ,GAAG,EAAE,CAAC,CAAC,GAAG;QACV,IAAI,EAAE,CAAC,CAAC,IAAI;KACb,CAAC,EAdmB,CAcnB,CAAC,CAAC;AACN,CAAC,EAAC;;;;;;;AC9HF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,8BAA8B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,YAAY;AACZ;AACA,sCAAsC;AACtC;AACA;AACA,UAAU;AACV;AACA;AACA,iDAAiD;AACjD;AACA,YAAY;AACZ;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA,MAAM;AACN,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA,8DAA8D;;AAE9D;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;AC/gBA,qCAAiE;AAEjE;;GAEG;AACH,sBAAe,UAAC,IAAY;IAC1B,IAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC1B,OAAG,GAAK,sBAAU,EAAC,QAAQ,CAAC,KAAK,CAAC,IAA/B,CAAgC;IAE3C,0CAA0C;IAC1C,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE;QAClB,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;KAC3D;IAED,OAAO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","sources":["webpack://seqparse/webpack/universalModuleDefinition","webpack://seqparse/./src/index.ts","webpack://seqparse/./src/fetchFile.ts","webpack://seqparse/external commonjs \"node-fetch\"","webpack://seqparse/./src/parseFile.ts","webpack://seqparse/./node_modules/path-browserify/index.js","webpack://seqparse/./src/parsers/benchling.ts","webpack://seqparse/./src/utils.ts","webpack://seqparse/./src/parsers/biobrick.ts","webpack://seqparse/external commonjs \"fast-xml-parser\"","webpack://seqparse/./src/parsers/fasta.ts","webpack://seqparse/./src/parsers/genbank.ts","webpack://seqparse/./src/parsers/jbei.ts","webpack://seqparse/./src/parsers/sbol.ts","webpack://seqparse/./src/parsers/sbol.v1.ts","webpack://seqparse/./src/parsers/sbol.v2.ts","webpack://seqparse/./src/parsers/seqbuilder.ts","webpack://seqparse/./src/parsers/snapgene.ts","webpack://seqparse/webpack/bootstrap","webpack://seqparse/webpack/before-startup","webpack://seqparse/webpack/startup","webpack://seqparse/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"seqparse\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"seqparse\"] = factory();\n\telse\n\t\troot[\"seqparse\"] = factory();\n})(this, () => {\nreturn ","import fetchFile, { isAccession } from \"./fetchFile\";\nimport parseFile from \"./parseFile\";\n\n/** Seq is a single parsed sequence from a file or accession. */\nexport interface Seq {\n  /** annotations of the sequence */\n  annotations: Annotation[];\n  /** name of the sequence */\n  name: string;\n  /** the sequence */\n  seq: string;\n  /** type of sequence. Inferred from the seq's symbols */\n  type: \"dna\" | \"rna\" | \"aa\" | \"unknown\";\n}\n\n/** Annotation is a single feature/annotation parsed from a sequence file. */\nexport interface Annotation {\n  /** color of the annotation if set */\n  color?: string;\n  /** 1 if forward, 0 if no direction, -1 if in reverse direction */\n  direction?: number;\n  /** end of the annotation, 0-based */\n  end: number;\n  /** name of the annotation */\n  name: string;\n  /** start of the annotation, 0-based */\n  start: number;\n  /** type field if set on the annotation */\n  type?: string;\n}\n\n/** Options to parse sequence files. */\nexport interface ParseOptions {\n  /**\n   * Whether to use cors-anywhere to circumvent iGEM's web server having a bad configuration.\n   */\n  cors?: boolean;\n\n  /** name of the source file */\n  fileName?: string;\n\n  /**\n   * Source of the file (ArrayBuffer). This is necessary for SnapGene.\n   *\n   * Eg after a read from FileReader.readAsArrayBuffer() in a browser:\n   * https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsArrayBuffer\n   */\n  source?: ArrayBuffer;\n}\n\n/* Parse a sequence file. Or download a sequence with an Accession ID. */\nexport default async (input: string, options?: ParseOptions): Promise<Seq> => {\n  if (!options?.fileName && isAccession(input)) {\n    return await fetchFile(input, options);\n  }\n  return parseFile(input, options)[0];\n};\n\nexport { parseFile };\n","import fetch, { Response } from \"node-fetch\";\n\nimport { ParseOptions, Seq } from \".\";\nimport parseFile from \"./parseFile\";\n\n/**\n * Get a remote sequence from NCBI or the iGEM registry.\n */\nexport default async (accession: string, options?: ParseOptions): Promise<Seq> => {\n  // The user doesn't specify the target registry, so we have to infer it from the passed accession: iGEM or NCBI\n  let url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&id=${accession.trim()}&rettype=gbwithparts&retmode=text`;\n  if (accession.startsWith(\"BB\")) {\n    // it's a BioBrick... target the iGEM repo\n    if ((typeof window !== \"undefined\" && typeof process === \"undefined\") || options?.cors) {\n      // use this hack to get around a no-CORS setting on iGEM webserver, pending fix on their side\n      url = `https://cors-anywhere.herokuapp.com/http://parts.igem.org/cgi/xml/part.cgi?part=${accession.trim()}`;\n    } else {\n      url = `http://parts.igem.org/cgi/xml/part.cgi?part=${accession.trim()}`;\n    }\n  }\n\n  // Request the XML from the webserver\n  let body = \"\";\n  let response: Response;\n  try {\n    response = await fetch(url);\n    body = await response.text();\n  } catch (err) {\n    throw new Error(`Failed to get part: accession=${accession} url=${url} err=${err}`);\n  }\n  if (!response.ok || !body.length) {\n    throw new Error(`Failed to get part, no body returned: accession=${accession} url=${url}`);\n  }\n\n  return (await parseFile(body))[0];\n};\n\n/** returns whether the passed ID is an accession in iGEM or NCBI */\nexport const isAccession = (accession: string): boolean => {\n  if (accession.startsWith(\"BB\")) {\n    return true; // biobrick\n  }\n  if (accession.length < 14 && accession.match(/^[a-z0-9_\\-.]+$/i)) {\n    return true;\n  }\n  return false;\n};\n","module.exports = require(\"node-fetch\");","import { sep } from \"path\";\n\nimport { ParseOptions, Seq } from \".\";\nimport parseBenchling from \"./parsers/benchling\";\nimport parseBioBrick from \"./parsers/biobrick\";\nimport parseFasta from \"./parsers/fasta\";\nimport parseGenbank from \"./parsers/genbank\";\nimport parseJbei from \"./parsers/jbei\";\nimport parseSbol from \"./parsers/sbol\";\nimport parseSeqBuilder from \"./parsers/seqbuilder\";\nimport parseSnapgene from \"./parsers/snapgene\";\nimport { complement, guessType } from \"./utils\";\n\n/**\n * parseFile converts the contents of a sequence file to a an array of Seq\n */\nexport default (file: string, opts?: ParseOptions): Seq[] => {\n  const fileName = opts?.fileName || \"\";\n  const sourceName = fileName.split(sep).pop() || fileName;\n\n  if (!file) {\n    throw Error(\"cannot parse null or empty string\");\n  }\n\n  // this is a check for an edge case, where the user uploads come kind\n  // of file that's full of bps but doesn't fit into a defined type\n  const firstLine = file.substring(0, file.search(\"\\n\"));\n  const dnaCharLength = firstLine.replace(/[^atcgATCG]/, \"\").length;\n  const dnaOnlyFile = dnaCharLength / firstLine.length > 0.8; // is it >80% dna?\n  const name = fileName && sourceName ? sourceName.substring(0, sourceName.search(\"\\\\.\")) : \"Untitled\";\n\n  // another edge case check for whether the seq is a JSON seq from Benchling\n  // just a heuristic that says 1) yes it can be parsed 2) it contains a list of\n  // fields that are common to Benchling files\n  let isBenchling = false;\n  try {\n    const benchlingJSON = JSON.parse(file); // will err out if not JSON\n    if ([\"bases\", \"annotations\", \"primers\"].every(k => typeof benchlingJSON[k] !== \"undefined\")) {\n      isBenchling = true;\n    }\n  } catch (ex) {\n    // expected\n  }\n\n  const prefix = file.substring(0, 200);\n  let seqs: Seq[];\n  switch (true) {\n    // JBEI\n    case prefix.includes(':seq=\"http://jbei.org/sequence\"'):\n    case file.startsWith(\"<seq:seq\"):\n      seqs = parseJbei(file);\n      break;\n\n    // FASTA\n    case file.startsWith(\">\"):\n    case file.startsWith(\";\"):\n    case fileName.endsWith(\".seq\"):\n    case fileName.endsWith(\".fa\"):\n    case fileName.endsWith(\".fas\"):\n    case fileName.endsWith(\".fasta\"):\n      seqs = parseFasta(file, fileName);\n      break;\n\n    // Genbank\n    case file.includes(\"LOCUS\") && file.includes(\"ORIGIN\"):\n    case fileName.endsWith(\".gb\"):\n    case fileName.endsWith(\".gbk\"):\n    case fileName.endsWith(\".genbank\"):\n    case fileName.endsWith(\".ape\"):\n      seqs = parseGenbank(file, fileName);\n      break;\n\n    // SnapGene\n    case fileName.endsWith(\".dna\"):\n      seqs = parseSnapgene(opts);\n      break;\n\n    // SeqBuilder\n    case prefix.includes(\"Written by SeqBuilder\"):\n    case fileName.endsWith(\".sbd\"):\n      seqs = parseSeqBuilder(file, fileName);\n      break;\n\n    // BioBrick XML\n    case prefix.includes(\"Parts from the iGEM\"):\n    case prefix.includes(\"<part_list>\"):\n      seqs = parseBioBrick(file);\n      break;\n\n    // Benchling JSON\n    case isBenchling:\n      seqs = parseBenchling(file);\n      break;\n\n    // SBOL\n    case prefix.includes(\"RDF\"):\n      seqs = parseSbol(file, fileName);\n      break;\n\n    // a DNA text file without an official formatting\n    case dnaOnlyFile: {\n      const { seq } = complement(file);\n      seqs = [{ annotations: [], name, seq, type: guessType(seq) }];\n      break;\n    }\n\n    default:\n      throw Error(`${fileName} File type not recognized: ${file}`);\n  }\n\n  // bit of clean up to: only return the fields in a Seq and reorder to match expectations.\n  return seqs.map(p => ({\n    annotations: p.annotations\n      .sort((a, b) => a.start - b.start || a.end - b.end)\n      .map(a => ({\n        color: a.color,\n        direction: a.direction,\n        end: a.end,\n        name: a.name,\n        start: a.start,\n        type: a.type,\n      })),\n    name: p.name,\n    seq: p.seq,\n    type: p.type,\n  }));\n};\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","import { Seq } from \"..\";\nimport { complement, guessType, parseDirection } from \"../utils\";\n\n/**\n * Benchling format is just JSON. It's virtually the same format.\n */\nexport default (text: string): Seq[] => {\n  const partJSON = JSON.parse(text);\n  const { seq } = complement(partJSON.bases);\n\n  // throw an error if the sequence is empty\n  if (seq.length < 1) {\n    throw new Error(\"Invalid Benchling part: empty sequence\");\n  }\n\n  return [\n    {\n      annotations: partJSON.annotations.map(a => ({\n        ...a,\n        direction: parseDirection(a.strand),\n      })),\n      name: partJSON.name || partJSON._id,\n      seq: seq,\n      type: guessType(seq),\n    },\n  ];\n};\n","// from http://arep.med.harvard.edu/labgc/adnan/projects/Utilities/revcomp.html\nconst comp = {\n  A: \"T\",\n  B: \"V\",\n  C: \"G\",\n  D: \"H\",\n  G: \"C\",\n  H: \"D\",\n  K: \"M\",\n  M: \"K\",\n  N: \"N\",\n  R: \"Y\",\n  S: \"S\",\n  T: \"A\",\n  U: \"A\",\n  V: \"B\",\n  W: \"W\",\n  X: \"X\",\n  Y: \"R\",\n  a: \"t\",\n  b: \"v\",\n  c: \"g\",\n  d: \"h\",\n  g: \"c\",\n  h: \"d\",\n  k: \"m\",\n  m: \"k\",\n  n: \"n\",\n  r: \"y\",\n  s: \"s\",\n  t: \"a\",\n  u: \"a\",\n  v: \"b\",\n  w: \"w\",\n  x: \"x\",\n  y: \"r\",\n};\n\n/**\n * Return the filtered sequence and its complement if its an empty string, return the same for both.\n */\nexport const complement = (origSeq: string): { compSeq: string; seq: string } => {\n  if (!origSeq) {\n    return { compSeq: \"\", seq: \"\" };\n  }\n\n  // filter out unrecognized basepairs and build up the complement\n  let seq = \"\";\n  let compSeq = \"\";\n  for (let i = 0, origLength = origSeq.length; i < origLength; i += 1) {\n    if (comp[origSeq[i]]) {\n      seq += origSeq[i];\n      compSeq += comp[origSeq[i]];\n    }\n  }\n  return { compSeq, seq };\n};\n\n/**\n * Return the reverse complement of a DNA sequence\n */\nexport const reverseComplement = (inputSeq: string): string => {\n  const { compSeq } = complement(inputSeq);\n  return compSeq.split(\"\").reverse().join(\"\");\n};\n\nexport const firstElement = (arr: any) => {\n  if (!Array.isArray(arr)) return undefined;\n  return arr[0];\n};\n\nconst fwd = new Set([\"FWD\", \"fwd\", \"FORWARD\", \"forward\", \"FOR\", \"for\", \"TOP\", \"top\", \"1\", 1]);\nconst rev = new Set([\"REV\", \"rev\", \"REVERSE\", \"reverse\", \"BOTTOM\", \"bottom\", \"-1\", -1]);\n\n/**\n * Parse the user defined direction, estimate the direction of the element\n *\n * ```js\n * parseDirection(\"FWD\") => 1\n * parseDirection(\"FORWARD\") => 1\n * ```\n */\nexport const parseDirection = (direction: number | string | undefined): -1 | 0 | 1 => {\n  if (!direction) {\n    return 0;\n  }\n  if (fwd.has(direction)) {\n    return 1;\n  }\n  if (rev.has(direction)) {\n    return -1;\n  }\n  return 0;\n};\n\n/**\n * mapping the 64 standard codons to amino acids\n * no synth AA's\n *\n * adapted from: \"https://github.com/keithwhor/NtSeq/blob/master/lib/nt.js\n */\nconst codon2AA = {\n  AAA: \"K\",\n  AAC: \"N\",\n  AAG: \"K\",\n  AAT: \"N\",\n  ACA: \"T\",\n  ACC: \"T\",\n  ACG: \"T\",\n  ACT: \"T\",\n  AGA: \"R\",\n  AGC: \"S\",\n  AGG: \"R\",\n  AGT: \"S\",\n  ATA: \"I\",\n  ATC: \"I\",\n  ATG: \"M\",\n  ATT: \"I\",\n  CAA: \"Q\",\n  CAC: \"H\",\n  CAG: \"Q\",\n  CAT: \"H\",\n  CCA: \"P\",\n  CCC: \"P\",\n  CCG: \"P\",\n  CCT: \"P\",\n  CGA: \"R\",\n  CGC: \"R\",\n  CGG: \"R\",\n  CGT: \"R\",\n  CTA: \"L\",\n  CTC: \"L\",\n  CTG: \"L\",\n  CTT: \"L\",\n  GAA: \"E\",\n  GAC: \"D\",\n  GAG: \"E\",\n  GAT: \"D\",\n  GCA: \"A\",\n  GCC: \"A\",\n  GCG: \"A\",\n  GCT: \"A\",\n  GGA: \"G\",\n  GGC: \"G\",\n  GGG: \"G\",\n  GGT: \"G\",\n  GTA: \"V\",\n  GTC: \"V\",\n  GTG: \"V\",\n  GTT: \"V\",\n  TAA: \"*\",\n  TAC: \"Y\",\n  TAG: \"*\",\n  TAT: \"Y\",\n  TCA: \"S\",\n  TCC: \"S\",\n  TCG: \"S\",\n  TCT: \"S\",\n  TGA: \"*\",\n  TGC: \"C\",\n  TGG: \"W\",\n  TGT: \"C\",\n  TTA: \"L\",\n  TTC: \"F\",\n  TTG: \"L\",\n  TTT: \"F\",\n};\n\nconst aminoAcids = Array.from(new Set(Object.values(codon2AA)).values()).join(\"\");\nconst aminoAcidRegex = new RegExp(`^[${aminoAcids}]+$`, \"i\");\n\n/** Infer the type of a sequence. This only allows a couple wildcard characters so may be overly strict. */\nexport const guessType = (seq: string): \"dna\" | \"rna\" | \"aa\" | \"unknown\" => {\n  if (/^[atgcn.]+$/i.test(seq)) {\n    return \"dna\";\n  } else if (/^[augcn.]+$/i.test(seq)) {\n    return \"rna\";\n  } else if (aminoAcidRegex.test(seq)) {\n    return \"aa\";\n  }\n  return \"unknown\";\n};\n","import { XMLParser } from \"fast-xml-parser\";\n\nimport { Seq } from \"..\";\nimport { complement, firstElement, guessType, parseDirection } from \"../utils\";\n\n/**\n * Parse a BioBrick in XML format to Seq[]\n *\n * Eg: https://parts.igem.org/cgi/xml/part.cgi?part=BBa_J23100\n */\nexport default (file: string): Seq[] => {\n  const bail = (err: string) => {\n    throw new Error(`Failed on BioBrick: ${err}`);\n  };\n\n  // parse\n  const parsedBiobrick = new XMLParser({\n    isArray: name => {\n      return [\"features\", \"part_name\", \"sequences\"].includes(name);\n    },\n    removeNSPrefix: true,\n  }).parse(file);\n\n  // get the first part\n  const { part } = parsedBiobrick.rsbpml.part_list;\n  if (!part) bail(\"No part seen in part_list\");\n\n  // extract the useful fields\n  const { features, part_name, sequences } = part;\n\n  const name = firstElement(part_name);\n\n  // parse the iGEM annotations\n  const annotations = features\n    .map(({ feature }) => {\n      if (!feature) return null;\n\n      const { direction, endpos, startpos, type } = feature;\n\n      return {\n        direction: parseDirection(direction),\n        end: +endpos,\n        name: `${direction}-${startpos}`,\n        start: +startpos || 0,\n        type: type || undefined,\n      };\n    })\n    .filter(a => a);\n\n  // parse the sequence\n  const { seq } = complement(sequences[0].seq_data);\n\n  return [\n    {\n      annotations: annotations,\n      name,\n      seq,\n      type: guessType(seq),\n    },\n  ];\n};\n","module.exports = require(\"fast-xml-parser\");","import { Seq } from \"..\";\nimport { guessType } from \"../utils\";\n\nexport default (text: string, fileName: string): Seq[] => {\n  // partFactory returns a negative \"circular\" prop, we assume they're all linear\n  if (text.trim().startsWith(\">\")) {\n    return text\n      .split(\">\") // split up if it's a multi-seq FASTA file\n      .map(t => {\n        // this starts at the end of the first line, grabs all other characters,\n        // and removes any newlines (leaving only the original sequence)\n        // sequence \"cleaning\" happens in complement (we don't support bps other than\n        // the most common right now)\n        const seq = t.substr(t.indexOf(\"\\n\"), t.length).replace(/\\s/g, \"\");\n\n        // the first line contains the name, though there's lots of variability around\n        // the information on this line...\n        // >MCHU - Calmodulin - Human, rabbit, bovine, rat, and chicken\n        const name = t.substring(0, t.search(/\\n|\\|/)).replace(/\\//g, \"\");\n\n        return {\n          annotations: [],\n          name,\n          seq,\n          type: guessType(seq),\n        };\n      })\n      .filter(p => p.name && p.seq);\n  }\n\n  if (text.trim().startsWith(\";\")) {\n    // it's an old-school style FASTA that's punctuated with semi-colons\n    // ;my|NAME\n    // ;my comment\n    // actGacgata\n    const name = text.substring(0, text.search(/\\n|\\|/)).replace(/\\//g, \"\");\n    const newlineBeforeSeq = text.indexOf(\"\\n\", text.lastIndexOf(\";\"));\n    const seq = text.substring(newlineBeforeSeq, text.length);\n    return [\n      {\n        annotations: [],\n        name,\n        seq,\n        type: guessType(seq),\n      },\n    ];\n  }\n\n  // assume that it's a no name FASTA. Ie it's just a file with dna and no header\n  // try and get the name from the fileName\n  const lastChar = fileName.lastIndexOf(\".\") || fileName.length;\n  const name = fileName.substring(0, lastChar) || \"Untitled\";\n  const seq = text;\n  return [\n    {\n      annotations: [],\n      name,\n      seq,\n      type: guessType(seq),\n    },\n  ];\n};\n","import { Annotation } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n// a list of recognized types that would constitute an annotation name\nconst tagNameSet = new Set([\"gene\", \"product\", \"note\", \"db_xref\", \"protein_id\", \"label\", \"lab_host\", \"locus_tag\"]);\n\n// a list of tags that could represent colors\nconst tagColorSet = new Set([\"ApEinfo_fwdcolor\", \"ApEinfo_revcolor\", \"loom_color\"]);\n\n/**\n * takes in a string representation of a GenBank file and outputs our\n * part representation of it. an example of a Genbank file can be found\n * at ./parsers/Gebank, though there is significant variability to the\n * format\n *\n * another official example can be found at:\n * https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html\n */\nexport default (fileInput: string, fileName: string) =>\n  fileInput\n    .split(/\\/\\/\\s/g)\n    .filter(f => f.length > 5)\n    .map(file => {\n      // the first row contains the name of the part and its creation date\n      // LOCUS       SCU49845     5028 bp    DNA             PLN       21-JUN-1999\n      const HEADER_ROW = file.substring(file.indexOf(\"LOCUS\"), file.search(/\\\\n|\\n/));\n      const [, name] = HEADER_ROW.split(/\\s{2,}/g).filter(h => h);\n\n      // trying to avoid giving a stupid name like Exported which Snapgene has by default\n      // also, if there is not name in header, the seq length will be used as name, which should\n      // be corrected (Number.parseInt to check for this case) https://stackoverflow.com/a/175787/7541747\n      let parsedName = name;\n      if (\n        (parsedName === \"Exported\" && file.includes(\"SnapGene\")) || // stupid Snapgene name\n        Number.parseInt(parsedName, 10) // it thinks seq-length is the name\n      ) {\n        // first try and get the name from ACCESSION\n        let accessionName = false;\n        if (file.includes(\"ACCESSION\")) {\n          // this will be undefined is there is no\n          const accession = file\n            .substring(file.indexOf(\"ACCESSION\"), file.indexOf(\"\\n\", file.indexOf(\"ACCESSION\")))\n            .replace(\".\", \"\")\n            .split(/\\s{2,}/)\n            .filter(a => a !== \"ACCESSION\")\n            .pop();\n          if (accession) {\n            parsedName = accession;\n            accessionName = true;\n          }\n        }\n\n        // otherwise, revert to trying to get the part name from the file name\n        if (!accessionName && fileName) {\n          parsedName = fileName\n            .substring(0, Math.max(fileName.search(/\\n|\\||\\./), fileName.lastIndexOf(\".\")))\n            .replace(/\\/\\s/g, \"\");\n        } else if (!accessionName) {\n          parsedName = \"Unnamed\"; // give up\n        }\n      }\n\n      // the part sequence is contained in and after the line that begins with ORIGIN\n      // do this before annotations so we can calc seqlength\n      //\n      // ORIGIN\n      //    1 gatcctccat atacaacggt atctccacct caggtttaga tctcaacaac ggaaccattg\n      //    61 ccgacatgag acagttaggt atcgtcgaga gttacaagct aaaacgagca gtagtcagct\n      const SEQ_ROWS = file.substring(file.lastIndexOf(\"ORIGIN\") + \"ORIGIN\".length, file.length);\n      let seq = SEQ_ROWS.replace(/[^gatc]/gi, \"\");\n      ({ seq } = complement(seq)); // seq and compSeq\n\n      // the features are translated into annotations\n      // region is FEATURES thru ORIGIN\n      // FEATURES             Location/Qualifiers\n      //   source          1..5028\n      //                   /organism=\"Saccharomyces cerevisiae\"\n      //                   /db_xref=\"taxon:4932\"\n      //                   /chromosome=\"IX\"\n      //                   /map=\"9\"\n      //\n      // in the example above, source is the annotation \"type\" and name is \"taxon:4932\"\n      // because \"db_xref\" is a recognized name type\n      // the name depends on whether the tag type is in the reocgnized list of types\n      const annotations: Annotation[] = [];\n      const primers = [];\n      if (file.indexOf(\"FEATURES\")) {\n        const FEATURES_LINE = file.indexOf(\"FEATURES\");\n        const FEATURES_NEW_LINE = file.indexOf(\"\\n\", FEATURES_LINE);\n        let ORIGIN_LINE = file.lastIndexOf(\"ORIGIN\");\n\n        // some files have a contig file line that needs to parsed out/ shouldn't be included in\n        // the features parsing\n        if (file.includes(\"CONTIG\")) {\n          ORIGIN_LINE = Math.min(ORIGIN_LINE, file.indexOf(\"CONTIG\"));\n        }\n        const FEATURES_ROWS = file\n          .substring(FEATURES_NEW_LINE, ORIGIN_LINE)\n          .split(/\\n/)\n          .filter(r => r);\n\n        FEATURES_ROWS.forEach(r => {\n          // in the example above, the following converts it to ['source', '1..5028']\n          const currLine = r.split(/\\s{2,}/g).filter(l => l);\n          if (currLine.length > 1) {\n            // it's the beginning of a new feature/annotation\n            const [type, rangeString] = currLine;\n            const rangeRegex = /\\d+/g;\n            const direction = r.includes(\"complement\") ? -1 : 1;\n\n            // using the example above, this parses 1..5028 into 1 and 5028\n            let [start, end] = [0, 0];\n            const startSearch = rangeRegex.exec(rangeString);\n\n            if (startSearch) {\n              // the - 1 is because genbank is 1-based while we're 0\n              start = +startSearch[0] - (1 % seq.length);\n              // single bp annotations are a thing in Genbank:\n              // https://github.com/Lattice-Automation/seqviz/issues/117\n              end = (start + 1) % seq.length;\n              const endSearch = rangeRegex.exec(rangeString);\n              if (endSearch) {\n                end = +endSearch[0] % seq.length;\n              }\n            }\n\n            if (type !== \"source\") {\n              // create a new annotation around the properties in this line (type and range)\n              annotations.push({\n                direction,\n                // set in next block\n                end,\n                name: \"\",\n                start,\n                type,\n              });\n            }\n          } else if (currLine.length === 1) {\n            // it's a continuation of a prior feature/annotation\n            // any updates (to name or color) to the last annotation should affect\n            // the last annotation that's in the array\n            if (currLine[0].startsWith(\"/\")) {\n              let [tag] = currLine;\n              tag = tag.replace(/[/\"]/g, \"\"); // get rid of quotation marks and forward slaches\n              // should now look like ['organism', 'Saccharomyces cerevisiae']\n              const [tagName, tagValue] = tag.split(/=/);\n\n              // the two values that can be extracted are name or color\n              const lastAnn = annotations.length - 1;\n              if (tagNameSet.has(tagName.toLowerCase())) {\n                // the key is something we recognize as an annotation name\n                if (lastAnn >= 0 && !annotations[lastAnn].name) {\n                  annotations[lastAnn].name = tagValue.trim();\n                }\n              } else if (tagColorSet.has(tagName)) {\n                // the key is something we recognize as an annotation color\n                if (lastAnn > -1) {\n                  annotations[lastAnn].color = tagValue;\n                }\n              }\n            }\n          }\n        });\n      }\n\n      return {\n        annotations: annotations,\n        name: parsedName.trim() || fileName,\n        primers: primers,\n        seq: seq,\n        type: guessType(seq),\n      };\n    });\n","import { XMLParser } from \"fast-xml-parser\";\n\nimport { Annotation, Seq } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n/**\n * Converts a JBEI file to a Seq\n *\n * https://j5.jbei.org/j5manual/pages/94.html\n */\nexport default (JBEI: string): Seq[] => {\n  // weird edge case with directed quotation characters\n  const fileString = JBEI.replace(/“|”/g, '\"');\n\n  // parse\n  const parsedJbei = new XMLParser({\n    removeNSPrefix: true,\n  }).parse(fileString);\n\n  // destructure the parameters from JBEI\n  const { seq } = parsedJbei;\n  const { features, name, sequence } = seq;\n\n  // attempt to get the name out of the JBEI\n  let parsedName = \"Unnamed\";\n  if (name) {\n    parsedName = name;\n  }\n\n  // attempt to get the sequence. fail if it's not findable\n  const { seq: parsedSeq } = complement(sequence); // seq and compSeq\n  if (!parsedSeq) return [];\n\n  // attempt to parse the JBEI annotations into our version of annotations\n  const annotations: Annotation[] = [];\n  if (features && features.feature) {\n    features.feature.forEach(feature => {\n      if (!feature) return;\n\n      const { complement, label, location, type } = feature;\n      if (location && location.genbankStart && location.end) {\n        annotations.push({\n          direction: complement ? -1 : 1,\n          // JBEI is 1-based\n          end: +location.end || 0,\n          name: label || \"Untitled\",\n          start: +location.genbankStart - 1 || 0,\n          type: type || \"N/A\",\n        });\n      }\n    });\n  }\n\n  return [\n    {\n      annotations: annotations,\n      name: parsedName,\n      seq: parsedSeq,\n      type: guessType(parsedSeq),\n    },\n  ];\n};\n","import { Seq } from \"..\";\nimport sbolV1 from \"./sbol.v1\";\nimport sbolV2 from \"./sbol.v2\";\n\n/**\n * takes in an SBOL file in v1 or v2 format, and parses to an array of parts\n * that match the Loom data model\n */\nexport default (sbol: string, fileName: string): Seq[] =>\n  sbol.includes(\"sbols.org/v1#\") ? sbolV1(sbol) : sbolV2(sbol, fileName);\n","import { XMLParser } from \"fast-xml-parser\";\n\nimport { Annotation, Seq } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n/*\n  <sbol:Sequence rdf:about=\"https://synbiohub.cidarlab.org/public/Demo/A1_sequence/1\">\n    <sbol:persistentIdentity rdf:resource=\"https://synbiohub.cidarlab.org/public/Demo/A1_sequence\"/>\n    <sbol:displayId>A1_sequence</sbol:displayId>\n    <sbol:version>1</sbol:version>\n    <prov:wasDerivedFrom rdf:resource=\"https://github.com/CIDARLAB/cello/blob/master/resources/UCF/Eco1C1G1T0.UCF.json\"/>\n    <prov:wasGeneratedBy rdf:resource=\"https://synbiohub.cidarlab.org/public/Demo/cello2sbol/1\"/>\n    <dcterms:title>A1_sequence</dcterms:title>\n    <sbh:ownedBy rdf:resource=\"https://synbiohub.cidarlab.org/user/prash\"/>\n    <sbh:topLevel rdf:resource=\"https://synbiohub.cidarlab.org/public/Demo/A1_sequence/1\"/>\n    <sbol:elements>AATGTTCCCTAATAATCAGCAAAGAGGTTACTAG</sbol:elements>\n    <sbol:encoding rdf:resource=\"http://www.chem.qmul.ac.uk/iubmb/misc/naseq.html\"/>\n  </sbol:Sequence>\n*/\n\n/**\n * takes an SBOL file, as a string, and converts it into our DB\n * representation of a part(s). an example of this type of file can be\n * found in ../examples/j5.SBOL.xml\n */\nexport default (sbol: string): Seq[] => {\n  // weird edge case with directed quotation characters\n  const fileString = sbol.replace(/“|”/g, '\"');\n\n  // parse\n  const parsedSBOL = new XMLParser({\n    ignoreAttributes: false,\n    isArray: name =>\n      [\n        \"Sequence\",\n        \"Collection\",\n        \"DnaComponent\",\n        \"dnaSequence\",\n        \"ComponentDefinition\",\n        \"SequenceAnnotation\",\n        \"sequenceAnnotation\",\n        \"elements\",\n        \"component\",\n        \"annotation\",\n      ].includes(name),\n    removeNSPrefix: true,\n  }).parse(fileString);\n\n  let RDF = null;\n  if (parsedSBOL.RDF) ({ RDF } = parsedSBOL);\n\n  // @ts-expect-error ts-migrate(2339) FIXME: Property 'Collection' does not exist on type 'null... Remove this comment to see the full error message\n  const { Collection, DnaComponent } = RDF;\n  if (Collection && Collection.length) {\n    // it's a collection of DnaComponents, parse each to a part\n    const partList = [];\n    Collection.forEach(({ component }) => {\n      if (component && component.length) {\n        component.forEach(({ DnaComponent: nestedDnaComponent }) => {\n          partList.push(\n            // @ts-expect-error ts-migrate(2345) FIXME: Argument of type '{ seq: string; compSeq: string; ... Remove this comment to see the full error message\n            dnaComponentToPart(nestedDnaComponent[0], {\n              file: sbol,\n              strict: false,\n            })\n          );\n        });\n      }\n    });\n\n    // check whether any parts were created from the collection\n    if (partList.length) return partList;\n  } else if (DnaComponent && DnaComponent.length) {\n    // create a single part from the single one passed\n    const validPart = dnaComponentToPart(DnaComponent[0], {\n      file: sbol,\n      strict: false,\n    });\n    // it will be null if there isn't any sequence information beneath it\n    if (validPart) return [validPart];\n  }\n\n  // go on a fishing expedition for DnaComponents\n  // everything else has failed\n  // accumulate all that are \"valid\" (name + seq)\n  const dnaComponentAccumulator = [];\n  findDnaComponentNodes(dnaComponentAccumulator, RDF);\n\n  // @ts-ignore\n  const attemptedSeqs: Seq[] = dnaComponentAccumulator\n    .map(p =>\n      dnaComponentToPart(p, {\n        file: sbol,\n        strict: true,\n      })\n    )\n    .filter(p => !!p); // invalid parts will be null\n  if (attemptedSeqs.length) return attemptedSeqs;\n\n  // go on another fishing expedition, but for Sequence nodes\n  const dnaSequenceAccumulator = [];\n  findSequenceNodes(dnaSequenceAccumulator, RDF);\n  return dnaSequenceAccumulator.map(p => sequenceToPart(p, sbol)).filter(p => p); // invalid parts will be null\n};\n\n/**\n * find all the nodes within the JSON document that are keyed \"Sequence\"\n *\n * this is another last-resort scrapper for trying to find valid parts\n */\nconst findSequenceNodes = (acc, doc) => {\n  Object.keys(doc).forEach(k => {\n    if (k === \"Sequence\" && doc[k].length) acc.push(...doc[k]);\n    if (Array.isArray(doc[k])) {\n      doc[k].forEach(nestedNode => {\n        findSequenceNodes(acc, nestedNode);\n      });\n    }\n  });\n};\n\n/**\n * after getting a DnaComponent out of the SBOL document,\n * at either the root RDF level or from within a Collection/Annotation\n * hierarchy, convert that DnaComponent to a Seq\n */\nconst dnaComponentToPart = (DnaComponent, options) => {\n  const { strict = false } = options;\n  // destructure the params from DnaComponent\n  const { annotation, displayId, dnaSequence, name } = DnaComponent;\n\n  // attempt to get the name out of the SBOL\n  let parsedName = \"Unnamed\";\n  if (name) {\n    parsedName = name;\n  } else if (displayId) {\n    parsedName = displayId;\n  } else if (strict) {\n    // in this scenario, we're really scrapping to find parts, but shouldn't\n    // accept any that don't at least have some name and sequence information\n    return null;\n  }\n\n  // attempt to get the sequence. fail if it's not findable\n  let seq = \"\";\n  if (dnaSequence && dnaSequence[0].DnaSequence) {\n    seq = dnaSequence[0].DnaSequence.nucleotides;\n  }\n\n  const { seq: parsedSeq } = complement(seq); // seq and compSeq\n  if (!parsedSeq) return null;\n\n  // attempt to parse the SBOL annotations into our version of annotations\n  const annotations: Annotation[] = [];\n  if (annotation) {\n    annotation.forEach(({ SequenceAnnotation }) => {\n      if (!SequenceAnnotation || !SequenceAnnotation[0]) return;\n\n      const { bioEnd, bioStart, strand, subComponent } = SequenceAnnotation[0];\n      if (subComponent && subComponent.DnaComponent && subComponent.DnaComponent[0]) {\n        const { displayId: annId, name: annName, type: annType } = subComponent.DnaComponent[0];\n\n        annotations.push({\n          direction: strand === \"+\" ? 1 : -1,\n          end: bioEnd - 1 || 0,\n          name: annName || annId || \"Untitled\",\n          start: bioStart - 1 || 0,\n          type: annType[\"@_resource\"] || \"N/A\",\n        });\n      }\n    });\n  }\n\n  return {\n    annotations: annotations,\n    name: parsedName,\n    seq: parsedSeq,\n    type: guessType(seq),\n  };\n};\n\n/**\n * find all nodes that of the type Sequence, and convert those to parts \"Sequence\" -> Part\n *\n * this is not the standard format. see A1.xml\n */\nconst sequenceToPart = (Seq, file) => {\n  // get the name\n  const name = Seq.displayId || Seq.title || \"Unnamed\";\n\n  // get the sequence\n  const seqOrig = Seq.elements[0] || \"\";\n\n  const { compSeq, seq } = complement(seqOrig);\n\n  // guess whether it's circular or not based on the presence of a word like vector.\n  // very ad hoc\n  const circular = file.search(/plasmid/i) > 0;\n\n  return { annotations: [], circular, compSeq, name, seq, type: guessType(seq) };\n};\n\n/**\n * find all the nodes within the SBOL JSON document that are keyed \"DnaComponent\"\n *\n * this is a last-resort scrapper that tries to find valid parts that aren't within a root\n * DnaComponent document or within a root Collection array\n */\nconst findDnaComponentNodes = (acc: Seq[], doc: any) => {\n  Object.keys(doc).forEach(k => {\n    if (k === \"DnaComponent\" && doc[k].length) acc.push(...doc[k]);\n    if (Array.isArray(doc[k])) {\n      doc[k].forEach(nestedNode => {\n        findDnaComponentNodes(acc, nestedNode);\n      });\n    }\n  });\n};\n","import { XMLParser } from \"fast-xml-parser\";\n\nimport { Annotation, Seq } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n/**\n * Converts an SBOL file to our Seq format.\n *\n * SBOL v2.0 schema definition can be found at: http://sbolstandard.org/wp-content/uploads/2016/06/SBOL-data-model-2.2.1.pdf\n * differs from SBOL v1.0 in that the ComponentDefinitions are like the root parts,\n * and the sequence and annotations are separated (they're no longer defined relationally\n * by nesting but, instead, by id) we only care about components that have sequence information\n */\nexport default (sbol: string, fileName: string): Seq[] => {\n  // weird edge case with directed quotation characters\n  const fileString = sbol.replace(/“|”/g, '\"');\n\n  // parse\n  const parsedSBOL = new XMLParser({\n    ignoreAttributes: false,\n    isArray: name =>\n      [\"Sequence\", \"ComponentDefinition\", \"SequenceAnnotation\", \"sequenceAnnotation\", \"elements\"].includes(name),\n    removeNSPrefix: true,\n  }).parse(fileString);\n\n  try {\n    const seqList = parseSBOL2(parsedSBOL, fileName);\n\n    if (seqList.length) {\n      return seqList;\n    } else {\n      throw new Error(\"No Sequence info found\");\n    }\n  } catch (err) {\n    throw new Error(`Failed to parse SBOL v2 file: ${err}`);\n  }\n};\n\nconst parseSBOL2 = (parsedSBOL, fileName: string): Seq[] => {\n  let RDF = null;\n  if (parsedSBOL.RDF) {\n    ({ RDF } = parsedSBOL);\n  }\n\n  if (!RDF) {\n    throw new Error(\"No root RDF document\");\n  }\n\n  // check if anything is defined, return if not\n  const { ComponentDefinition, Sequence } = RDF;\n  if (!ComponentDefinition && !Sequence) {\n    throw new Error(\"Failed to parse SBOL v2: No ComponentDefinition or Sequence\");\n  }\n\n  // read thru the Sequence elements\n  const getSeq = (seqID?: string) => {\n    const seqElement = seqID\n      ? // @ts-ignore\n        Sequence.find(\n          s =>\n            (s.persistentIdentity && s.persistentIdentity.length && s.persistentIdentity[\"@_resource\"] === seqID) ||\n            s[\"@_about\"] === seqID\n        )\n      : Sequence[0];\n\n    if (seqElement && seqElement.elements) {\n      const { seq } = complement(seqElement.elements[0] || \"\");\n      return {\n        annotations: [],\n        name: seqElement.displayId,\n        seq,\n        type: guessType(seq),\n      };\n    }\n    return null;\n  };\n\n  // if it's a collection of DnaComponents, parse each to a part\n  const seqList: Seq[] = [];\n  // @ts-ignore\n  ComponentDefinition?.forEach((c, i) => {\n    // we're only making parts out of those with seq info\n    if (!c.sequence) {\n      return;\n    }\n\n    const { displayId, sequence, sequenceAnnotation } = c;\n    const name = displayId || `${fileName}_${i + 1}`;\n\n    const annotations: Annotation[] = [];\n    (sequenceAnnotation || []).forEach(({ SequenceAnnotation }) => {\n      const ann = SequenceAnnotation[0];\n      const annId = ann.displayId;\n      const { Range } = ann.location;\n\n      const range = Range;\n      if (range) {\n        annotations.push({\n          end: range.end - 1,\n          name: annId,\n          start: range.start - 1,\n        });\n      }\n    });\n\n    const seq = getSeq(sequence[\"@_resource\"]);\n\n    if (seq) {\n      seqList.push({\n        annotations,\n        name,\n        seq: seq.seq,\n        type: seq.type,\n      });\n    }\n  });\n\n  // if it's a single sequence, just try and get the sequence from that alone\n  const seq = getSeq();\n  if (!seqList.length && seq) {\n    seqList.push(seq);\n  }\n  return seqList;\n};\n","import { Annotation } from \"..\";\nimport { complement, guessType } from \"../utils\";\n\n// a list of recognized types that would constitute an annotation name\nconst tagNameList = [\"gene\", \"product\", \"note\", \"db_xref\", \"protein_id\", \"label\", \"lab_host\"];\n\n// a list of tags that could represent colors\nconst tagColorList = [\"ApEinfo_fwdcolor\", \"ApEinfo_revcolor\", \"loom_color\"];\n\n/**\n * takes in a string representation of a SeqBuilder file and outputs our\n * part representation of it. an example of a SeqBuilder file can be found\n * at imports/io/examples/seqbuilder, though there may be variations to the\n * format\n */\nexport default (fileInput: string, fileName: string) =>\n  fileInput.split(/\\/\\/\\s/g).map(file => {\n    // +++++SEQUENCE+++++//\n    // the part sequence comes after the line that specifies the seqbuilder version number\n    // @ts-ignore\n    const SEQ_ROWS = file\n      .substring(\n        file.search(/.*?written by seqbuilder .*?[0-9.]+[^actg]+/i) +\n          // @ts-ignore\n          file.match(/.*?written by seqbuilder .*?[0-9.]+[^actg]+/i)[0].length,\n        file.length\n      )\n      .match(/[actgyrwskmdvhbxn]+/gim)[0];\n\n    let seq = SEQ_ROWS;\n    ({ seq } = complement(seq)); // seq and compSeq\n    // there may be a genbank-like header row after the sequence\n    // LOCUS       SCU49845     5028 bp    DNA             PLN       21-JUN-1999\n    let parsedName = fileName.length > 0 ? fileName : \"Unnamed\";\n\n    if (~file.indexOf(\"LOCUS\")) {\n      const HEADER_ROW = file.substring(file.indexOf(\"LOCUS\"), file.search(/\\\\n|\\n/));\n      if (HEADER_ROW && HEADER_ROW.split(/\\s{2,}/g)) {\n        const [, name] = HEADER_ROW.split(/\\s{2,}/g).filter(h => h);\n        parsedName = name;\n      }\n    }\n    // Name setting logic ported from GenBank parser\n    if (\n      (parsedName === \"Exported\" && file.includes(\"SnapGene\")) || // stupid Snapgene name\n      Number.parseInt(parsedName, 10) // it thinks seq-length is the name\n    ) {\n      // first try and get the name from ACCESSION\n      let accessionName = false;\n      if (file.includes(\"ACCESSION\")) {\n        // this will be undefined is there is no\n        const accession = file\n          .substring(file.indexOf(\"ACCESSION\"), file.indexOf(\"\\n\", file.indexOf(\"ACCESSION\")))\n          .replace(\".\", \"\")\n          .split(/\\s{2,}/)\n          .filter(a => a !== \"ACCESSION\")\n          .pop();\n        if (accession) {\n          parsedName = accession;\n          accessionName = true;\n        }\n      }\n\n      // otherwise, revert to trying to get the part name from the file name\n      if (!accessionName && fileName) {\n        parsedName = fileName\n          .substring(0, Math.max(fileName.search(/\\n|\\||\\./), fileName.lastIndexOf(\".\")))\n          .replace(/\\/\\s/g, \"\");\n      } else if (!accessionName) {\n        parsedName = \"Unnamed\"; // give up\n      }\n    }\n\n    // +++++ANNOTATIONS+++++//\n    // the features are translated into annotations\n    // region is FEATURES thru ORIGIN\n    // FEATURES             Location/Qualifiers\n    //   source          1..5028\n    //                   /organism=\"Saccharomyces cerevisiae\"\n    //                   /db_xref=\"taxon:4932\"\n    //                   /chromosome=\"IX\"\n    //                   /map=\"9\"\n    //\n    // in the example above, source is the annotation \"type\" and name is \"taxon:4932\"\n    // because \"db_xref\" is a recognized name type\n    // the name depends on whether the tag type is in the reocgnized list of types\n    const annotations: Annotation[] = [];\n    if (file.indexOf(\"FEATURES\")) {\n      const FEATURES_LINE = file.indexOf(\"FEATURES\");\n      const FEATURES_NEW_LINE = file.indexOf(\"\\n\", FEATURES_LINE);\n      let ORIGIN_LINE = file.lastIndexOf(\"ORIGIN\");\n\n      // some files have a contig file line that needs to parsed out/ shouldn't be included in\n      // the features parsing\n      if (file.includes(\"CONTIG\")) {\n        ORIGIN_LINE = Math.min(ORIGIN_LINE, file.indexOf(\"CONTIG\"));\n      }\n      const FEATURES_ROWS = file\n        .substring(FEATURES_NEW_LINE, ORIGIN_LINE)\n        .split(/\\n/)\n        .filter(r => r);\n\n      FEATURES_ROWS.forEach(r => {\n        // in the example above, the following converts it to ['source', '1..5028']\n        const currLine = r.split(/\\s{2,}/g).filter(l => l);\n        if (currLine.length > 1) {\n          // it's the beginning of a new feature/annotation\n          const [type, rangeString] = currLine;\n          const rangeRegex = /\\d+/g;\n          const direction = r.includes(\"complement\") ? -1 : 1;\n\n          // using the example above, this parses 1..5028 into 1 and 5028\n          let [start, end] = [0, 0];\n          const startSearch = rangeRegex.exec(rangeString);\n\n          if (startSearch) {\n            // the - 1 is because genbank is 1-based while we're 0\n            start = +startSearch[0] - (1 % seq.length);\n            const endSearch = rangeRegex.exec(rangeString);\n            if (endSearch) {\n              end = +endSearch[0] % seq.length;\n            }\n          }\n\n          if (type !== \"source\") {\n            // source would just be an annotation for the entire sequence so remove\n            // create a new annotation around the properties in this line (type and range)\n            annotations.push({\n              direction,\n              end,\n              name: \"\",\n              start,\n              type,\n            });\n          }\n        } else if (currLine.length === 1) {\n          // it's a continuation of a prior feature/annotation\n          // any updates (to name or color) to the last annotation should affect\n          // the last annotation that's in the array\n          let [tag] = currLine;\n          tag = tag.replace(/[/\"]/g, \"\"); // get rid of quotation marks and forward slaches\n          // should now look like ['organism', 'Saccharomyces cerevisiae']\n          const [tagName, tagValue] = tag.split(/=/);\n\n          // the two values that can be extracted are name or color\n          const lastAnnIndex = annotations.length - 1;\n          if (tagNameList.includes(tagName)) {\n            // it's key value pair where the key is something we recognize as an annotation name\n            if (lastAnnIndex > -1 && !annotations[annotations.length - 1].name) {\n              // defensively check that there isn't already a defined annotation w/o a name\n              annotations[annotations.length - 1].name = tagValue.trim();\n            }\n          } else if (tagColorList.includes(tagName)) {\n            // it's key value pair where the key is something we recognize as an annotation color\n            if (lastAnnIndex > -1) {\n              // defensively check that there's already been a defined annotation\n              annotations[annotations.length - 1].color = tagValue;\n            }\n          }\n        }\n      });\n    }\n\n    return {\n      annotations: annotations,\n      name: parsedName.trim() || fileName,\n      seq: seq,\n      type: guessType(seq),\n    };\n  });\n","import { XMLParser } from \"fast-xml-parser\";\nimport { sep } from \"path\";\n\nimport { Annotation, ParseOptions, Seq } from \"..\";\nimport { guessType, parseDirection } from \"../utils\";\n\n/**\n * Parse a SnapGene file to Seq[]\n *\n * this is adapted from https://github.com/TeselaGen/ve-sequence-parsers/blob/master/src/parsers/snapgeneToJson.js\n * which was adapted from https://github.com/IsaacLuo/SnapGeneFileReader/blob/master/snapgene_reader/snapgene_reader.py\n */\nexport default (options?: ParseOptions): Seq[] => {\n  if (!options || !options.source) {\n    throw new Error(\"Failed to parse SnapGene file. No valid file input\");\n  }\n\n  const fileName = options?.fileName || \"\";\n  const seq = {\n    annotations: [] as Annotation[],\n    circular: false,\n    name: \"\",\n    seq: \"\",\n    type: \"unknown\",\n  };\n\n  const buffer = Buffer.from(options.source);\n\n  // Accumulate an offset from the start as we read through the file\n  let offset = 0;\n\n  // Read a buffer from the buffer\n  const read = (size: number) => {\n    const start = offset;\n    offset += size;\n    return buffer.subarray(start, offset);\n  };\n\n  // Read from buffer and decode as string\n  const readEnc = (size: number, fmt: BufferEncoding) => read(size).toString(fmt);\n\n  // Read the first byte\n  read(1);\n\n  // Read document properties\n  const length = read(4).readUInt32BE();\n  const title = readEnc(8, \"ascii\");\n  if (length !== 14 || title !== \"SnapGene\") {\n    throw new Error(`Wrong format for a SnapGene file: length=${length} title=${title}`);\n  }\n\n  read(2); // isDNA\n  read(2); // exportVersion\n  read(2); // importVersion\n\n  /* eslint-disable no-await-in-loop */\n  // READ THE WHOLE FILE, BLOCK BY BLOCK, UNTIL THE END\n  while (offset < buffer.length) {\n    // next_byte table\n    // 0: dna sequence\n    // 1: compressed DNA\n    // 2: unknown\n    // 3: unknown\n    // 5: primers\n    // 6: notes\n    // 7: history tree\n    // 8: additional sequence properties segment\n    // 9: file Description\n    // 10: features\n    // 11: history node\n    // 13: unknown\n    // 16: alignable sequence\n    // 17: alignable sequence\n    // 18: sequence trace\n    // 19: Uracil Positions\n    // 20: custom DNA colors\n\n    const nextByte = read(1);\n    const blockSize = read(4).readUInt32BE();\n    const ord = nextByte.toString().charCodeAt(0);\n    if (ord === 0) {\n      // Read the sequence and its properties\n      read(1); // isCircular\n\n      const size = blockSize - 1;\n      if (size < 0) throw new Error(\"Failed parsing SnapGene: < 0 length sequence\");\n      seq.seq = readEnc(size, \"ascii\");\n    } else if (ord === 10) {\n      // Read all the features\n      const xml = readEnc(blockSize, \"utf8\") as string;\n      const b = new XMLParser({\n        attributeNamePrefix: \"\",\n        ignoreAttributes: false,\n        isArray: name => name === \"Q\" || name === \"Segment\",\n        removeNSPrefix: true,\n      }).parse(xml);\n\n      b.Features.Feature.forEach(feature => {\n        let minStart = 0;\n        let maxEnd = 0;\n        const { range } = feature.Segment[0];\n        const [start, end] = range.split(\"-\");\n        minStart = minStart === 0 ? +start : Math.min(minStart, +start);\n        maxEnd = Math.max(maxEnd, +end);\n\n        // create an Annotation\n        seq.annotations.push({\n          direction: parseDirection(\n            {\n              \"0\": \"NONE\",\n              \"1\": 1,\n              \"2\": -1,\n              \"3\": \"BIDIRECTIONAL\",\n              undefined: \"NONE\",\n            }[feature.directionality]\n          ),\n          end: maxEnd - 1,\n          name: feature.name,\n          start: minStart - 1,\n          type: feature.type,\n        });\n      });\n    } else {\n      // UNKNOWN: WE IGNORE THE WHOLE BLOCK\n      read(blockSize);\n    }\n  }\n\n  return [\n    {\n      ...seq,\n      // SnapGene uses the filename as the sequence name\n      name: fileName.split(sep).pop()?.replace(\".dna\", \"\") || fileName,\n      type: guessType(seq.seq),\n    },\n  ];\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(0);\n",""],"names":[],"sourceRoot":""}